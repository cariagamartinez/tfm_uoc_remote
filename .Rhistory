})
# Crear una tabla de codificación para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),         # Niveles originales
Codigo = as.numeric(factor_x)     # Códigos numéricos
)
} else {
NULL
}
})
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
View(codificacion)
# Convertir las columnas character a factores y luego a valores numéricos
datos[] <- lapply(datos, function(x) {
if (is.character(x)) {
as.numeric(factor(x))  # Convierte a factor y luego a numérico
} else {
x  # Deja sin cambios si no es character
}
})
View(datos)
# Convertir las columnas character a factores y luego a valores numéricos, y guardar en un nuevo data.frame
datos_numericos <- lapply(datos, function(x) {
if (is.character(x)) {
as.numeric(factor(x))  # Convierte a factor y luego a numérico
} else {
x  # Deja sin cambios si no es character
}
})
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
View(datos_numericos)
View(datos)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
options(max.print = 10000)
summary(datos)
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
datos_dem <- datos %>%
select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir las columnas character a factores y luego a valores numéricos, y guardar en un nuevo data.frame
datos_numericos <- lapply(datos, function(x) {
if (is.character(x)) {
as.numeric(factor(x))  # Convierte a factor y luego a numérico
} else {
x  # Deja sin cambios si no es character
}
})
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
View(datos)
View(valores_unicos)
View(datos_numericos)
View(codificacion)
md.pattern(datos_numericos)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
options(max.print = 10000)
summary(datos)
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
datos_dem <- datos %>%
select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir columnas character a factores numéricos, manteniendo NA
datos_numericos <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
as.numeric(factor_x)[!is.na(x)] <- NA  # Mantiene NA sin cambios
as.numeric(factor_x)
} else {
x  # Deja sin cambios si no es character
}
})
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
options(max.print = 10000)
summary(datos)
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
datos_dem <- datos %>%
select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir columnas character a factores numéricos, manteniendo NA
datos_numericos <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
as.numeric(factor_x)[!is.na(x)] <- NA  # Mantiene NA sin cambios
as.numeric(factor_x)
} else {
x  # Deja sin cambios si no es character
}
})
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
options(max.print = 10000)
summary(datos)
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
datos_dem <- datos %>%
select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir las columnas character a factores numéricos, manteniendo los NA
datos_numericos <- lapply(datos, function(x) {
if (is.character(x)) {
# Convertir a factor y luego a numérico, preservando los NA
as.numeric(factor(x, exclude = NULL))  # `exclude = NULL` mantiene los NA como NA
} else {
x  # Deja sin cambios si no es character
}
})
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
md.pattern(datos_numericos)
View(codificacion)
View(datos)
View(datos_dem)
View(datos_numericos)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
options(max.print = 10000)
summary(datos)
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
datos_dem <- datos %>%
select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir columnas character a factores numéricos, manteniendo los NA
datos_numericos <- datos %>%
mutate(across(where(is.character), ~ as.numeric(factor(., exclude = NULL))))
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
md.pattern(datos_numericos)
View(datos_numericos)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
# Convertir valores vacíos a NA en todo el dataset usando dplyr
datos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .)))
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
# datos_dem <- datos %>%
#   select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
codificacion <- lapply(datos, function(x) {
if (is.character(x)) {
factor_x <- factor(x)
data.frame(
Nivel = levels(factor_x),                    # Niveles únicos
Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
)
} else {
NULL
}
})
# Imprimir la tabla de codificación de cada columna
codificacion
# Convertir columnas character a factores numéricos, manteniendo los NA
datos_numericos <- datos %>%
mutate(across(where(is.character), ~ as.numeric(factor(., exclude = NULL))))
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
# Convertir la lista resultante en un data.frame
datos_numericos <- as.data.frame(datos_numericos)
md.pattern(datos_numericos)
View(datos)
View(datos_numericos)
# Reemplazar valores vacíos con NA y luego convertir columnas character a factores numéricos, manteniendo los NA
datos_numericos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%  # Paso 1: reemplazar "" con NA
mutate(across(where(is.character), ~ as.numeric(factor(., exclude = NULL))))  # Paso 2: convertir a factor y luego a numérico
View(datos_numericos)
View(datos)
View(datos_numericos)
View(codificacion)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
# Convertir valores vacíos a NA en todo el dataset usando dplyr
datos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .)))
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
# datos_dem <- datos %>%
#   select(sex, ag, el)
#Ver la lista de valores únicos
valores_unicos <- lapply(datos, unique)
# # Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
# codificacion <- lapply(datos, function(x) {
#   if (is.character(x)) {
#     factor_x <- factor(x)
#     data.frame(
#       Nivel = levels(factor_x),                    # Niveles únicos
#       Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
#     )
#   } else {
#     NULL
#   }
# })
#
# # Imprimir la tabla de codificación de cada columna
# codificacion
# Reemplazar valores vacíos con NA y luego convertir columnas character a factores numéricos, manteniendo los NA
datos_numericos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%  # Paso 1: reemplazar "" con NA
mutate(across(where(is.character), ~ as.numeric(factor(., exclude = NULL))))  # Paso 2: convertir a factor y luego a numérico
md.pattern(datos_numericos)
View(datos_numericos)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
# Convertir valores vacíos a NA en todo el dataset usando dplyr
datos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .)))
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
# datos_dem <- datos %>%
#   select(sex, ag, el)
#Ver la lista de valores únicos
#valores_unicos <- lapply(datos, unique)
# # Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
# codificacion <- lapply(datos, function(x) {
#   if (is.character(x)) {
#     factor_x <- factor(x)
#     data.frame(
#       Nivel = levels(factor_x),                    # Niveles únicos
#       Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
#     )
#   } else {
#     NULL
#   }
# })
#
# # Imprimir la tabla de codificación de cada columna
# codificacion
# Convertir valores vacíos a NA y luego convertir columnas character a factores numéricos, manteniendo los NA originales
datos_numericos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%  # Paso 1: reemplazar "" con NA
mutate(across(where(is.character), ~ ifelse(is.na(.), NA, as.numeric(factor(.)))))
md.pattern(datos_numericos)
View(datos_numericos)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
# Convertir valores vacíos a NA y luego convertir columnas character a factores numéricos, manteniendo los NA originales
datos_numericos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%  # Paso 1: reemplazar "" con NA
mutate(across(where(is.character), ~ ifelse(is.na(.), NA, as.numeric(factor(.)))))
md.pattern(datos_numericos, rotate.names = T)
#Cargamos librerías
library(tidyverse)
library(mice)
library(naniar)
#Carga del dataset global
datos <- read.csv("BBDD/bbddAECM_07_10_24.csv")
md.pattern(datos, rotate.names = T)
# Convertir valores vacíos a NA en todo el dataset usando dplyr
datos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .)))
glimpse(datos)
# Realizar el test MCAR
#mcar_test_result <- mcar_test(datos)
# Mostrar el resultado
#print(mcar_test_result)
#Generación de subsets de interés
# datos_dem <- datos %>%
#   select(sex, ag, el)
#Ver la lista de valores únicos
#valores_unicos <- lapply(datos, unique)
# # Crear una tabla de codificación de niveles y códigos únicos para cada columna de texto
# codificacion <- lapply(datos, function(x) {
#   if (is.character(x)) {
#     factor_x <- factor(x)
#     data.frame(
#       Nivel = levels(factor_x),                    # Niveles únicos
#       Codigo = seq_along(levels(factor_x))         # Códigos numéricos únicos
#     )
#   } else {
#     NULL
#   }
# })
#
# # Imprimir la tabla de codificación de cada columna
# codificacion
# Convertir valores vacíos a NA y luego convertir columnas character a factores numéricos, manteniendo los NA originales
datos_numericos <- datos %>%
mutate(across(everything(), ~ ifelse(. == "", NA, .))) %>%  # Paso 1: reemplazar "" con NA
mutate(across(where(is.character), ~ ifelse(is.na(.), NA, as.numeric(factor(.)))))
md.pattern(datos_numericos, rotate.names = T)
total_na <- sum(is.na(datos))
print(total_na)
total_na <- sum(is.na(datos_numericos))
print(total_na)
# Convertir el data.frame a formato largo y contar frecuencias
frecuencias_df <- datos %>%
pivot_longer(cols = everything(), names_to = "columna", values_to = "valor") %>%
count(columna, valor, name = "frecuencia")
#Ver posibles desbalances
# Convertir todas las columnas a character antes de usar pivot_longer
datos_char <- datos %>%
mutate(across(everything(), as.character))
# Convertir el data.frame a formato largo y contar frecuencias
frecuencias_df <- datos_char %>%
pivot_longer(cols = everything(), names_to = "columna", values_to = "valor") %>%
count(columna, valor, name = "frecuencia")
# Ver frecuencias por columna
print(frecuencias_df)
View(frecuencias_df)
# Filtrar solo las columnas que son character
datos_char <- datos %>%
select(where(is.character))
# Convertir el data.frame filtrado a formato largo y contar frecuencias
frecuencias_df <- datos_char %>%
pivot_longer(cols = everything(), names_to = "columna", values_to = "valor") %>%
count(columna, valor, name = "frecuencia")
# Ver frecuencias por columna
print(frecuencias_df)
View(frecuencias_df)
# Total de observaciones no nulas en todo el dataset
total_observaciones_no_na <- sum(!is.na(datos))
print(total_observaciones_no_na)
# Total de observaciones (incluyendo NA) en todo el dataset
total_observaciones <- nrow(datos) * ncol(datos)
print(total_observaciones)
install.packages("missForest")
# Aplicar el método missForest a tu dataset
imputacion <- missForest(datos)
# Aplicar el método missForest a tu dataset
imputacion <- missForest(datos)
library(missForest)
# Aplicar el método missForest a tu dataset
imputacion <- missForest(datos)
# Aplicar el método missForest a tu dataset
imputacion <- missForest(datos_numericos)
imputacion <- missForest(datos_numericos)
datos_imputados <- imputacion$ximp
View(datos_imputados)
# Ver el dataset imputado
head(datos_imputados)
# Ver la tasa de error de la imputación
imputacion$OOBerror
# Aplicar el método missForest a tu dataset
imputacion <- missForest(datos_numericos, ntree = 200, maxiter = 5)
